// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ReactFreshTypeScriptTransformer can handle implicit arrow returns 1`] = `
var _a, _b, _c, _d, _e;
var _f, _g, _h, _j, _k, _l;
_f = $RefreshSig$();
_g = $RefreshSig$();
_h = $RefreshSig$();
_j = $RefreshSig$();
_k = $RefreshSig$();
_l = $RefreshSig$();
export default () => (_f(), useContext(X));
export const Foo = _g(() => (_g(), useContext(X)), \`useContext{}\`, false);
_a = Foo;
module.exports = () => (_h(), useContext(X));
const Bar = _j(() => (_j(), useContext(X)), \`useContext{}\`, false);
_b = Bar;
const Baz = memo(_c = _k(() => (_k(), useContext(X)), \`useContext{}\`, false));
_d = Baz;
const Qux = _l(() => (_l(), (0, useContext(X))), \`useContext{}\`, false);
_e = Qux;
$RefreshReg$(_a, "Foo");
$RefreshReg$(_b, "Bar");
$RefreshReg$(_c, "Baz$memo");
$RefreshReg$(_d, "Baz");
$RefreshReg$(_e, "Qux");

`;

exports[`ReactFreshTypeScriptTransformer does not consider require-like methods to be HOCs 1`] = `
var _a;
const A = require('A');
const B = foo ? require('X') : require('Y');
const C = requireCond(gk, 'C');
const D = import('D');
export default function App() {
    return (<div>
      <A />
      <B />
      <C />
      <D />
    </div>);
}
_a = App;
$RefreshReg$(_a, "App");

`;

exports[`ReactFreshTypeScriptTransformer generates signatures for function declarations calling hooks 1`] = `
var _a;
var _b;
_b = $RefreshSig$();
export default function App() {
    _b();
    const [foo, setFoo] = useState(0);
    React.useEffect(() => { });
    return <h1>{foo}</h1>;
}
_a = App;
_b(App, \`useState{[foo, setFoo](0)}
useEffect{}\`, false);
$RefreshReg$(_a, "App");

`;

exports[`ReactFreshTypeScriptTransformer generates signatures for function expressions calling hooks 1`] = `
var _a, _b, _c, _d, _e, _f;
var _g, _h;
_g = $RefreshSig$();
_h = $RefreshSig$();
export const A = React.memo(_a = React.forwardRef(_b = _g((props, ref) => {
    _g();
    const [foo, setFoo] = useState(0);
    React.useEffect(() => { });
    return <h1 ref={ref}>{foo}</h1>;
}, \`useState{[foo, setFoo](0)}
useEffect{}\`, false)));
_c = A;
export const B = React.memo(_d = React.forwardRef(_e = _h(function (props, ref) {
    _h();
    const [foo, setFoo] = useState(0);
    React.useEffect(() => { });
    return <h1 ref={ref}>{foo}</h1>;
}, \`useState{[foo, setFoo](0)}
useEffect{}\`, false)));
_f = B;
function hoc() {
    var _a;
    _a = $RefreshSig$();
    return _a(function Inner() {
        _a();
        const [foo, setFoo] = useState(0);
        React.useEffect(() => { });
        return <h1 ref={ref}>{foo}</h1>;
    }, \`useState{[foo, setFoo](0)}
useEffect{}\`, false);
}
export let C = hoc();
$RefreshReg$(_b, "A$React.memo$React.forwardRef");
$RefreshReg$(_a, "A$React.memo");
$RefreshReg$(_c, "A");
$RefreshReg$(_e, "B$React.memo$React.forwardRef");
$RefreshReg$(_d, "B$React.memo");
$RefreshReg$(_f, "B");

`;

exports[`ReactFreshTypeScriptTransformer generates valid signature for exotic ways to call Hooks 1`] = `
var _a;
var _b;
_b = $RefreshSig$();
import FancyHook from 'fancy';
export default function App() {
    _b();
    var _a;
    _a = $RefreshSig$();
    function useFancyState() {
        _a();
        const [foo, setFoo] = React.useState(0);
        useFancyEffect();
        return foo;
    }
    _a(useFancyState, \`useState{[foo, setFoo](0)}
useFancyEffect{}\`, false);
    const bar = useFancyState();
    const baz = FancyHook.useThing();
    React.useState();
    useThePlatform();
    return <h1>{bar}{baz}</h1>;
}
_a = App;
_b(App, \`useFancyState{bar}
FancyHook.useThing{baz}
useState{}
useThePlatform{}\`, false);
$RefreshReg$(_a, "App");

`;

exports[`ReactFreshTypeScriptTransformer ignores HOC definitions 1`] = `
let connect = () => {
    function Comp() {
        const handleClick = () => { };
        return <h1 onClick={handleClick}>Hi</h1>;
    }
    return Comp;
};
function withRouter() {
    return function Child() {
        const handleClick = () => { };
        return <h1 onClick={handleClick}>Hi</h1>;
    };
}
;

`;

exports[`ReactFreshTypeScriptTransformer ignores complex definitions 1`] = `
var _a;
let A = foo ? () => {
    return <h1>Hi</h1>;
} : null;
const B = (function Foo() {
    return <h1>Hi</h1>;
})();
let C = () => () => {
    return <h1>Hi</h1>;
};
_a = C;
let D = bar && (() => {
    return <h1>Hi</h1>;
});
$RefreshReg$(_a, "C");

`;

exports[`ReactFreshTypeScriptTransformer ignores higher-order functions that are not HOCs 1`] = `
var _a;
const throttledAlert = throttle(_a = function () {
    alert('Hi');
});
const TooComplex = (function () { return hello; })(() => { });
if (cond) {
    const Foo = thing(() => { });
}
$RefreshReg$(_a, "throttledAlert$throttle");

`;

exports[`ReactFreshTypeScriptTransformer ignores unnamed function declarations 1`] = `
export default function () { }

`;

exports[`ReactFreshTypeScriptTransformer includes custom hooks into the signatures 1`] = `
var _a;
var _b, _c, _d;
_b = $RefreshSig$();
_c = $RefreshSig$();
_d = $RefreshSig$();
function useFancyState() {
    _b();
    const [foo, setFoo] = React.useState(0);
    useFancyEffect();
    return foo;
}
_b(useFancyState, \`useState{[foo, setFoo](0)}
useFancyEffect{}\`, false);
const useFancyEffect = _c(() => {
    _c();
    React.useEffect(() => { });
}, \`useEffect{}\`, false);
export default function App() {
    _d();
    const bar = useFancyState();
    return <h1>{bar}</h1>;
}
_a = App;
_d(App, \`useFancyState{bar}\`, false);
$RefreshReg$(_a, "App");

`;

exports[`ReactFreshTypeScriptTransformer includes custom hooks into the signatures when commonjs target is used 1`] = `
var _a;
var _b;
_b = $RefreshSig$();
import { useFancyState } from './hooks';
export default function App() {
    _b();
    const bar = useFancyState();
    return <h1>{bar}</h1>;
}
_a = App;
_b(App, \`useFancyState{bar}\`, false);
$RefreshReg$(_a, "App");

`;

exports[`ReactFreshTypeScriptTransformer only registers pascal case functions 1`] = `
function hello() {
    return 2 * 2;
}

`;

exports[`ReactFreshTypeScriptTransformer registers capitalized identifiers in HOC calls 1`] = `
var _a, _b, _c, _d;
function Foo() {
    return <h1>Hi</h1>;
}
_a = Foo;
export default _b = hoc(Foo);
export const A = hoc(Foo);
_c = A;
const B = hoc(Foo);
_d = B;
$RefreshReg$(_a, "Foo");
$RefreshReg$(_b, "%default%");
$RefreshReg$(_c, "A");
$RefreshReg$(_d, "B");

`;

exports[`ReactFreshTypeScriptTransformer registers identifiers used in JSX at definition site 1`] = `
var _a, _b, _c, _d, _e, _f, _g;
import A from './A';
import Store from './Store';
Store.subscribe();
const Header = styled.div \`color: red\`;
_a = Header;
const StyledFactory1 = styled('div') \`color: hotpink\`;
_b = StyledFactory1;
const StyledFactory2 = styled('div')({ color: 'hotpink' });
_c = StyledFactory2;
const StyledFactory3 = styled(A)({ color: 'hotpink' });
_d = StyledFactory3;
const FunnyFactory = funny.factory \`\`;
let Alias1 = A;
let Alias2 = A.Foo;
const Dict = {};
function Foo() {
    return (<div><A /><B /><StyledFactory1 /><StyledFactory2 /><StyledFactory3 /><Alias1 /><Alias2 /><Header /><Dict.X /></div>);
}
_e = Foo;
const B = hoc(A);
_f = B;
// This is currently registered as a false positive:
const NotAComponent = wow(A);
_g = NotAComponent;
$RefreshReg$(_a, "Header");
$RefreshReg$(_b, "StyledFactory1");
$RefreshReg$(_c, "StyledFactory2");
$RefreshReg$(_d, "StyledFactory3");
$RefreshReg$(_e, "Foo");
$RefreshReg$(_f, "B");
$RefreshReg$(_g, "NotAComponent");

`;

exports[`ReactFreshTypeScriptTransformer registers identifiers used in React.createElement at definition site 1`] = `
var _a, _b, _c, _d, _e, _f, _g;
import A from './A';
import Store from './Store';
Store.subscribe();
const Header = styled.div \`color: red\`;
_a = Header;
const StyledFactory1 = styled('div') \`color: hotpink\`;
_b = StyledFactory1;
const StyledFactory2 = styled('div')({ color: 'hotpink' });
_c = StyledFactory2;
const StyledFactory3 = styled(A)({ color: 'hotpink' });
_d = StyledFactory3;
const FunnyFactory = funny.factory \`\`;
let Alias1 = A;
let Alias2 = A.Foo;
const Dict = {};
function Foo() {
    return [
        React.createElement(A),
        React.createElement(B),
        React.createElement(StyledFactory1),
        React.createElement(StyledFactory2),
        React.createElement(StyledFactory3),
        React.createElement(Alias1),
        React.createElement(Alias2),
        jsx(Header),
        React.createElement(Dict.X),
    ];
}
_e = Foo;
React.createContext(Store);
const B = hoc(A);
_f = B;
// This is currently registered as a false positive:
const NotAComponent = wow(A);
_g = NotAComponent;
$RefreshReg$(_a, "Header");
$RefreshReg$(_b, "StyledFactory1");
$RefreshReg$(_c, "StyledFactory2");
$RefreshReg$(_d, "StyledFactory3");
$RefreshReg$(_e, "Foo");
$RefreshReg$(_f, "B");
$RefreshReg$(_g, "NotAComponent");

`;

exports[`ReactFreshTypeScriptTransformer registers likely HOCs with inline functions 1`] = `
var _a, _b, _c, _d, _e, _f, _g, _h;
const A = forwardRef(_a = function () {
    return <h1>Foo</h1>;
});
_b = A;
const B = memo(_c = React.forwardRef(_d = () => {
    return <h1>Foo</h1>;
}));
_e = B;
export default _h = React.memo(_f = forwardRef(_g = (props, ref) => {
    return <h1>Foo</h1>;
}));
$RefreshReg$(_a, "A$forwardRef");
$RefreshReg$(_b, "A");
$RefreshReg$(_d, "B$memo$React.forwardRef");
$RefreshReg$(_c, "B$memo");
$RefreshReg$(_e, "B");
$RefreshReg$(_g, "%default%$React.memo$forwardRef");
$RefreshReg$(_f, "%default%$React.memo");
$RefreshReg$(_h, "%default%");

`;

exports[`ReactFreshTypeScriptTransformer registers likely HOCs with inline functions 2`] = `
var _a, _b, _c;
export default _c = React.memo(_a = forwardRef(_b = function (props, ref) {
    return <h1>Foo</h1>;
}));
$RefreshReg$(_b, "%default%$React.memo$forwardRef");
$RefreshReg$(_a, "%default%$React.memo");
$RefreshReg$(_c, "%default%");

`;

exports[`ReactFreshTypeScriptTransformer registers likely HOCs with inline functions 3`] = `
var _a, _b, _c;
export default _c = React.memo(_a = forwardRef(_b = function Named(props, ref) {
    return <h1>Foo</h1>;
}));
$RefreshReg$(_b, "%default%$React.memo$forwardRef");
$RefreshReg$(_a, "%default%$React.memo");
$RefreshReg$(_c, "%default%");

`;

exports[`ReactFreshTypeScriptTransformer registers top-level exported function declarations 1`] = `
var _a, _b, _c;
export function Hello() {
    function handleClick() { }
    return <h1 onClick={handleClick}>Hi</h1>;
}
_a = Hello;
export default function Bar() {
    return <Hello />;
}
_b = Bar;
function Baz() {
    return <h1>OK</h1>;
}
_c = Baz;
const NotAComp = 'hi';
export { Baz, NotAComp };
export function sum() { }
export const Bad = 42;
$RefreshReg$(_a, "Hello");
$RefreshReg$(_b, "Bar");
$RefreshReg$(_c, "Baz");

`;

exports[`ReactFreshTypeScriptTransformer registers top-level exported named arrow functions 1`] = `
var _a, _b;
export const Hello = () => {
    function handleClick() { }
    return <h1 onClick={handleClick}>Hi</h1>;
};
_a = Hello;
export let Bar = (props) => <Hello />;
_b = Bar;
export default () => {
    // This one should be ignored.
    // You should name your components.
    return <Hello />;
};
$RefreshReg$(_a, "Hello");
$RefreshReg$(_b, "Bar");

`;

exports[`ReactFreshTypeScriptTransformer registers top-level function declarations 1`] = `
var _a, _b;
function Hello() {
    function handleClick() { }
    return <h1 onClick={handleClick}>Hi</h1>;
}
_a = Hello;
function Bar() {
    return <Hello />;
}
_b = Bar;
$RefreshReg$(_a, "Hello");
$RefreshReg$(_b, "Bar");

`;

exports[`ReactFreshTypeScriptTransformer registers top-level variable declarations with arrow functions 1`] = `
var _a, _b, _c;
let Hello = () => {
    const handleClick = () => { };
    return <h1 onClick={handleClick}>Hi</h1>;
};
_a = Hello;
const Bar = () => {
    return <Hello />;
};
_b = Bar;
var Baz = () => <div />;
_c = Baz;
var sum = () => { };
$RefreshReg$(_a, "Hello");
$RefreshReg$(_b, "Bar");
$RefreshReg$(_c, "Baz");

`;

exports[`ReactFreshTypeScriptTransformer registers top-level variable declarations with function expressions 1`] = `
var _a, _b;
let Hello = function () {
    function handleClick() { }
    return <h1 onClick={handleClick}>Hi</h1>;
};
_a = Hello;
const Bar = function Baz() {
    return <Hello />;
};
_b = Bar;
function sum() { }
let Baz = 10;
var Qux;
$RefreshReg$(_a, "Hello");
$RefreshReg$(_b, "Bar");

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 1`] = `
var _a;
var _b;
_b = $RefreshSig$();
export function StateTest() {
    _b();
    const a = useState(0, extra);
    const [b] = useState(complex + expression.f());
    const [c, d] = React.useState();
    const [[e], f] = useState([0]);
    const { 0: y, 1: z, length } = useState(() => {
        a();
        multiple();
        line();
        expression();
    });
}
_a = StateTest;
_b(StateTest, \`useState{a(0)}
useState{[b](complex + expression.f())}
useState{[c, d]}
useState{[[e], f]([0])}
useState{{ 0: y, 1: z, length }(() => {
    a();
    multiple();
    line();
    expression();
})}\`, false);
$RefreshReg$(_a, "StateTest");

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 2`] = `
var _a;
var _b;
_b = $RefreshSig$();
export function RefTest() {
    _b();
    const ref = useRef();
    const ref2 = useRef(complex.expr(1), extra);
    const { current } = React.useRef();
}
_a = RefTest;
_b(RefTest, \`useRef{ref}
useRef{ref2}
useRef{{ current }}\`, false);
$RefreshReg$(_a, "RefTest");

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 3`] = `
var _a;
var _b;
_b = $RefreshSig$();
export function EffectTest() {
    _b();
    const rtn = useEffect();
    useEffect(expr, [deps]);
    useEffect(() => {
        do_some();
    });
    useEffect(() => (sideEffect(), () => undo()));
}
_a = EffectTest;
_b(EffectTest, \`useEffect{rtn}
useEffect{}
useEffect{}
useEffect{}\`, false);
$RefreshReg$(_a, "EffectTest");

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 4`] = `
var _a;
var _b;
_b = $RefreshSig$();
export function ContextTest() {
    _b();
    const ctx = useContext(expr);
    const { val } = useContext(expr2, extra);
    useContext(expr3);
}
_a = ContextTest;
_b(ContextTest, \`useContext{ctx}
useContext{{ val }}
useContext{}\`, false);
$RefreshReg$(_a, "ContextTest");

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 5`] = `
var _a;
var _b;
_b = $RefreshSig$();
export function ReducerTest() {
    _b();
    const [state, dispatch] = useReducer(reducer, initArg, init, extra);
    useReducer();
}
_a = ReducerTest;
_b(ReducerTest, \`useReducer{[state, dispatch](initArg)}
useReducer{}\`, false);
$RefreshReg$(_a, "ReducerTest");

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 6`] = `
var _a;
var _b;
_b = $RefreshSig$();
export function CallbackTest() {
    _b();
    const x = useCallback(() => { });
    const [p] = [useCallback(a, [a, b])];
}
_a = CallbackTest;
_b(CallbackTest, \`useCallback{x}
useCallback{}\`, false);
$RefreshReg$(_a, "CallbackTest");

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 7`] = `
var _a;
var _b;
_b = $RefreshSig$();
export function MemoTest() {
    _b();
    const x = useMemo(() => { });
    const [p] = [useMemo(a, [a, b])];
}
_a = MemoTest;
_b(MemoTest, \`useMemo{x}
useMemo{}\`, false);
$RefreshReg$(_a, "MemoTest");

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 8`] = `
var _a, _b, _c;
var _d, _e;
_d = $RefreshSig$();
_e = $RefreshSig$();
function ImperativeHandle(props, ref) {
    _d();
    const v = useImperativeHandle(ref, () => ({ a }));
}
_a = ImperativeHandle;
_d(ImperativeHandle, \`useImperativeHandle{v}\`, false);
ImperativeHandle = forwardRef(ImperativeHandle);
const HOC = forwardRef(_b = _e(function (props, ref) {
    _e();
    const v = useImperativeHandle(ref, () => ({ a }));
}, \`useImperativeHandle{v}\`, false));
_c = HOC;
$RefreshReg$(_a, "ImperativeHandle");
$RefreshReg$(_b, "HOC$forwardRef");
$RefreshReg$(_c, "HOC");

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 9`] = `
var _a;
var _b;
_b = $RefreshSig$();
function LayoutEffect() { _b(); const v = useLayoutEffect(ref); }
_a = LayoutEffect;
_b(LayoutEffect, \`useLayoutEffect{v}\`, false);
$RefreshReg$(_a, "LayoutEffect");

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 10`] = `
var _a;
var _b;
_b = $RefreshSig$();
function DebugValue() { _b(); const v = useDebugValue(ref, f); }
_a = DebugValue;
_b(DebugValue, \`useDebugValue{v}\`, false);
$RefreshReg$(_a, "DebugValue");

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for custom hooks 1`] = `
var _a;
var _b;
_b = $RefreshSig$();
function A() {
    _b();
    const [x] = useCustom(1, 2, 3);
    useCustom();
}
_a = A;
_b(A, \`useCustom{[x]}
useCustom{}\`, false);
$RefreshReg$(_a, "A");

`;

exports[`ReactFreshTypeScriptTransformer uses custom identifiers for $RefreshReg$ and $RefreshSig$ 1`] = `
var _a;
var _b;
_b = import.meta.refreshSig();
export default function Bar() {
    _b();
    useContext(X);
    return <Foo />;
}
_a = Bar;
_b(Bar, \`useContext{}\`, false);
;
import.meta.refreshReg(_a, "Bar");

`;

exports[`ReactFreshTypeScriptTransformer uses original function declaration if it get reassigned 1`] = `
var _a;
function Hello() {
    return <h1>Hi</h1>;
}
_a = Hello;
Hello = connect(Hello);
$RefreshReg$(_a, "Hello");

`;
