// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ReactFreshTypeScriptTransformer can handle implicit arrow returns 1`] = `
var $c6, $c7, $c8, $c9, $c10;
var $c0, $c1, $c2, $c3, $c4, $c5;
$c0 = $RefreshSig$();
$c1 = $RefreshSig$();
$c2 = $RefreshSig$();
$c3 = $RefreshSig$();
$c4 = $RefreshSig$();
$c5 = $RefreshSig$();
export default $c0(() => ($c0(), useContext(X)), "useContext{}");
export const Foo = $c1(() => ($c1(), useContext(X)), "useContext{}");
$c6 = Foo;
$RefreshReg$($c6, "Foo");
module.exports = () => ($c2(), useContext(X));
const Bar = $c3(() => ($c3(), useContext(X)), "useContext{}");
$c7 = Bar;
$RefreshReg$($c7, "Bar");
const Baz = memo($c8 = $c4(() => ($c4(), useContext(X)), "useContext{}"));
$RefreshReg$($c8, "Baz$memo");
$c9 = Baz;
$RefreshReg$($c9, "Baz");
const Qux = $c5(() => ($c5(), (0, useContext(X))), "useContext{}");
$c10 = Qux;
$RefreshReg$($c10, "Qux");

`;

exports[`ReactFreshTypeScriptTransformer does not consider require-like methods to be HOCs 1`] = `
var $c0;
const A = require('A');
const B = foo ? require('X') : require('Y');
const C = requireCond(gk, 'C');
const D = import('D');
export default function App() {
    return (<div>
      <A />
      <B />
      <C />
      <D />
    </div>);
}
$c0 = App;
$RefreshReg$($c0, "App");

`;

exports[`ReactFreshTypeScriptTransformer generates signatures for function declarations calling hooks 1`] = `
var $c1;
var $c0;
$c0 = $RefreshSig$();
export default function App() {
    $c0();
    const [foo, setFoo] = useState(0);
    React.useEffect(() => { });
    return <h1>{foo}</h1>;
}
$c1 = App;
$RefreshReg$($c1, "App");
$c0(App, \`useState{[foo, setFoo](0)}
useEffect{}\`);

`;

exports[`ReactFreshTypeScriptTransformer generates signatures for function expressions calling hooks 1`] = `
var $c3, $c4, $c5, $c6, $c7, $c8;
var $c0, $c1;
$c0 = $RefreshSig$();
$c1 = $RefreshSig$();
export const A = React.memo($c3 = React.forwardRef($c4 = $c0((props, ref) => {
    $c0();
    const [foo, setFoo] = useState(0);
    React.useEffect(() => { });
    return <h1 ref={ref}>{foo}</h1>;
}, \`useState{[foo, setFoo](0)}
useEffect{}\`)));
$RefreshReg$($c4, "A$React.memo$React.forwardRef");
$RefreshReg$($c3, "A$React.memo");
$c5 = A;
$RefreshReg$($c5, "A");
export const B = React.memo($c6 = React.forwardRef($c7 = $c1(function (props, ref) {
    $c1();
    const [foo, setFoo] = useState(0);
    React.useEffect(() => { });
    return <h1 ref={ref}>{foo}</h1>;
}, \`useState{[foo, setFoo](0)}
useEffect{}\`)));
$RefreshReg$($c7, "B$React.memo$React.forwardRef");
$RefreshReg$($c6, "B$React.memo");
$c8 = B;
$RefreshReg$($c8, "B");
function hoc() {
    var $c2;
    $c2 = $RefreshSig$();
    return $c2(function Inner() {
        $c2();
        const [foo, setFoo] = useState(0);
        React.useEffect(() => { });
        return <h1 ref={ref}>{foo}</h1>;
    }, \`useState{[foo, setFoo](0)}
useEffect{}\`);
}
export let C = hoc();

`;

exports[`ReactFreshTypeScriptTransformer generates valid signature for exotic ways to call Hooks 1`] = `
var $c2;
var $c1;
$c1 = $RefreshSig$();
import FancyHook from 'fancy';
export default function App() {
    $c1();
    var $c0;
    $c0 = $RefreshSig$();
    function useFancyState() {
        $c0();
        const [foo, setFoo] = React.useState(0);
        useFancyEffect();
        return foo;
    }
    $c0(useFancyState, \`useState{[foo, setFoo](0)}
useFancyEffect{}\`, true);
    const bar = useFancyState();
    const baz = FancyHook.useThing();
    React.useState();
    useThePlatform();
    return <h1>{bar}{baz}</h1>;
}
$c2 = App;
$RefreshReg$($c2, "App");
$c1(App, \`useFancyState{bar}
FancyHook.useThing{baz}
useState{}
useThePlatform{}\`, true);

`;

exports[`ReactFreshTypeScriptTransformer ignores HOC definitions 1`] = `
let connect = () => {
    function Comp() {
        const handleClick = () => { };
        return <h1 onClick={handleClick}>Hi</h1>;
    }
    return Comp;
};
function withRouter() {
    return function Child() {
        const handleClick = () => { };
        return <h1 onClick={handleClick}>Hi</h1>;
    };
}
;

`;

exports[`ReactFreshTypeScriptTransformer ignores complex definitions 1`] = `
var $c0;
let A = foo ? () => {
    return <h1>Hi</h1>;
} : null;
const B = (function Foo() {
    return <h1>Hi</h1>;
})();
let C = () => () => {
    return <h1>Hi</h1>;
};
$c0 = C;
$RefreshReg$($c0, "C");
let D = bar && (() => {
    return <h1>Hi</h1>;
});

`;

exports[`ReactFreshTypeScriptTransformer ignores higher-order functions that are not HOCs 1`] = `
var $c0;
const throttledAlert = throttle($c0 = function () {
    alert('Hi');
});
$RefreshReg$($c0, "throttledAlert$throttle");
const TooComplex = (function () { return hello; })(() => { });
if (cond) {
    const Foo = thing(() => { });
}

`;

exports[`ReactFreshTypeScriptTransformer ignores unnamed function declarations 1`] = `
export default function () { }

`;

exports[`ReactFreshTypeScriptTransformer includes custom hooks into the signatures 1`] = `
var $c3;
var $c0, $c1, $c2;
$c0 = $RefreshSig$();
$c1 = $RefreshSig$();
$c2 = $RefreshSig$();
function useFancyState() {
    $c0();
    const [foo, setFoo] = React.useState(0);
    useFancyEffect();
    return foo;
}
$c0(useFancyState, \`useState{[foo, setFoo](0)}
useFancyEffect{}\`, false, () => [useFancyEffect]);
const useFancyEffect = $c1(() => {
    $c1();
    React.useEffect(() => { });
}, "useEffect{}");
export default function App() {
    $c2();
    const bar = useFancyState();
    return <h1>{bar}</h1>;
}
$c3 = App;
$RefreshReg$($c3, "App");
$c2(App, "useFancyState{bar}", false, () => [useFancyState]);

`;

exports[`ReactFreshTypeScriptTransformer includes custom hooks into the signatures when commonjs target is used 1`] = `
var $c1;
var $c0;
$c0 = $RefreshSig$();
import { useFancyState } from './hooks';
export default function App() {
    $c0();
    const bar = useFancyState();
    return <h1>{bar}</h1>;
}
$c1 = App;
$RefreshReg$($c1, "App");
$c0(App, "useFancyState{bar}", false, () => [useFancyState]);

`;

exports[`ReactFreshTypeScriptTransformer only registers pascal case functions 1`] = `
function hello() {
    return 2 * 2;
}

`;

exports[`ReactFreshTypeScriptTransformer registers capitalized identifiers in HOC calls 1`] = `
var $c0, $c1, $c2, $c3;
function Foo() {
    return <h1>Hi</h1>;
}
$c0 = Foo;
$RefreshReg$($c0, "Foo");
export default $c1 = hoc(Foo);
$RefreshReg$($c1, "%default%");
export const A = hoc(Foo);
$c2 = A;
$RefreshReg$($c2, "A");
const B = hoc(Foo);
$c3 = B;
$RefreshReg$($c3, "B");

`;

exports[`ReactFreshTypeScriptTransformer registers identifiers used in JSX at definition site 1`] = `
var $c0, $c1, $c2, $c3, $c4, $c5, $c6;
import A from './A';
import Store from './Store';
Store.subscribe();
const Header = styled.div \`color: red\`;
$c0 = Header;
$RefreshReg$($c0, "Header");
const StyledFactory1 = styled('div') \`color: hotpink\`;
$c1 = StyledFactory1;
$RefreshReg$($c1, "StyledFactory1");
const StyledFactory2 = styled('div')({ color: 'hotpink' });
$c2 = StyledFactory2;
$RefreshReg$($c2, "StyledFactory2");
const StyledFactory3 = styled(A)({ color: 'hotpink' });
$c3 = StyledFactory3;
$RefreshReg$($c3, "StyledFactory3");
const FunnyFactory = funny.factory \`\`;
let Alias1 = A;
let Alias2 = A.Foo;
const Dict = {};
function Foo() {
    return (<div><A /><B /><StyledFactory1 /><StyledFactory2 /><StyledFactory3 /><Alias1 /><Alias2 /><Header /><Dict.X /></div>);
}
$c4 = Foo;
$RefreshReg$($c4, "Foo");
const B = hoc(A);
$c5 = B;
$RefreshReg$($c5, "B");
// This is currently registered as a false positive:
const NotAComponent = wow(A);
$c6 = NotAComponent;
$RefreshReg$($c6, "NotAComponent");

`;

exports[`ReactFreshTypeScriptTransformer registers identifiers used in React.createElement at definition site 1`] = `
var $c0, $c1, $c2, $c3, $c4, $c5, $c6;
import A from './A';
import Store from './Store';
Store.subscribe();
const Header = styled.div \`color: red\`;
$c0 = Header;
$RefreshReg$($c0, "Header");
const StyledFactory1 = styled('div') \`color: hotpink\`;
$c1 = StyledFactory1;
$RefreshReg$($c1, "StyledFactory1");
const StyledFactory2 = styled('div')({ color: 'hotpink' });
$c2 = StyledFactory2;
$RefreshReg$($c2, "StyledFactory2");
const StyledFactory3 = styled(A)({ color: 'hotpink' });
$c3 = StyledFactory3;
$RefreshReg$($c3, "StyledFactory3");
const FunnyFactory = funny.factory \`\`;
let Alias1 = A;
let Alias2 = A.Foo;
const Dict = {};
function Foo() {
    return [
        React.createElement(A),
        React.createElement(B),
        React.createElement(StyledFactory1),
        React.createElement(StyledFactory2),
        React.createElement(StyledFactory3),
        React.createElement(Alias1),
        React.createElement(Alias2),
        jsx(Header),
        React.createElement(Dict.X),
    ];
}
$c4 = Foo;
$RefreshReg$($c4, "Foo");
React.createContext(Store);
const B = hoc(A);
$c5 = B;
$RefreshReg$($c5, "B");
// This is currently registered as a false positive:
const NotAComponent = wow(A);
$c6 = NotAComponent;
$RefreshReg$($c6, "NotAComponent");

`;

exports[`ReactFreshTypeScriptTransformer registers likely HOCs with inline functions 1`] = `
var $c0, $c1, $c2, $c3, $c4, $c5, $c6, $c7;
const A = forwardRef($c0 = function () {
    return <h1>Foo</h1>;
});
$RefreshReg$($c0, "A$forwardRef");
$c1 = A;
$RefreshReg$($c1, "A");
const B = memo($c2 = React.forwardRef($c3 = () => {
    return <h1>Foo</h1>;
}));
$RefreshReg$($c3, "B$memo$React.forwardRef");
$RefreshReg$($c2, "B$memo");
$c4 = B;
$RefreshReg$($c4, "B");
export default $c7 = React.memo($c5 = forwardRef($c6 = (props, ref) => {
    return <h1>Foo</h1>;
}));
$RefreshReg$($c7, "%default%");
$RefreshReg$($c6, "%default%$React.memo$forwardRef");
$RefreshReg$($c5, "%default%$React.memo");

`;

exports[`ReactFreshTypeScriptTransformer registers likely HOCs with inline functions 2`] = `
var $c0, $c1, $c2;
export default $c2 = React.memo($c0 = forwardRef($c1 = function (props, ref) {
    return <h1>Foo</h1>;
}));
$RefreshReg$($c2, "%default%");
$RefreshReg$($c1, "%default%$React.memo$forwardRef");
$RefreshReg$($c0, "%default%$React.memo");

`;

exports[`ReactFreshTypeScriptTransformer registers likely HOCs with inline functions 3`] = `
var $c0, $c1, $c2;
export default $c2 = React.memo($c0 = forwardRef($c1 = function Named(props, ref) {
    return <h1>Foo</h1>;
}));
$RefreshReg$($c2, "%default%");
$RefreshReg$($c1, "%default%$React.memo$forwardRef");
$RefreshReg$($c0, "%default%$React.memo");

`;

exports[`ReactFreshTypeScriptTransformer registers top-level exported function declarations 1`] = `
var $c0, $c1, $c2;
export function Hello() {
    function handleClick() { }
    return <h1 onClick={handleClick}>Hi</h1>;
}
$c0 = Hello;
$RefreshReg$($c0, "Hello");
export default function Bar() {
    return <Hello />;
}
$c1 = Bar;
$RefreshReg$($c1, "Bar");
function Baz() {
    return <h1>OK</h1>;
}
$c2 = Baz;
$RefreshReg$($c2, "Baz");
const NotAComp = 'hi';
export { Baz, NotAComp };
export function sum() { }
export const Bad = 42;

`;

exports[`ReactFreshTypeScriptTransformer registers top-level exported named arrow functions 1`] = `
var $c0, $c1;
export const Hello = () => {
    function handleClick() { }
    return <h1 onClick={handleClick}>Hi</h1>;
};
$c0 = Hello;
$RefreshReg$($c0, "Hello");
export let Bar = (props) => <Hello />;
$c1 = Bar;
$RefreshReg$($c1, "Bar");
export default () => {
    // This one should be ignored.
    // You should name your components.
    return <Hello />;
};

`;

exports[`ReactFreshTypeScriptTransformer registers top-level function declarations 1`] = `
var $c0, $c1;
function Hello() {
    function handleClick() { }
    return <h1 onClick={handleClick}>Hi</h1>;
}
$c0 = Hello;
$RefreshReg$($c0, "Hello");
function Bar() {
    return <Hello />;
}
$c1 = Bar;
$RefreshReg$($c1, "Bar");

`;

exports[`ReactFreshTypeScriptTransformer registers top-level variable declarations with arrow functions 1`] = `
var $c0, $c1, $c2;
let Hello = () => {
    const handleClick = () => { };
    return <h1 onClick={handleClick}>Hi</h1>;
};
$c0 = Hello;
$RefreshReg$($c0, "Hello");
const Bar = () => {
    return <Hello />;
};
$c1 = Bar;
$RefreshReg$($c1, "Bar");
var Baz = () => <div />;
$c2 = Baz;
$RefreshReg$($c2, "Baz");
var sum = () => { };

`;

exports[`ReactFreshTypeScriptTransformer registers top-level variable declarations with function expressions 1`] = `
var $c0, $c1;
let Hello = function () {
    function handleClick() { }
    return <h1 onClick={handleClick}>Hi</h1>;
};
$c0 = Hello;
$RefreshReg$($c0, "Hello");
const Bar = function Baz() {
    return <Hello />;
};
$c1 = Bar;
$RefreshReg$($c1, "Bar");
function sum() { }
let Baz = 10;
var Qux;

`;

exports[`ReactFreshTypeScriptTransformer should correctly compile when downgrade 1`] = `
var $c0;
$c0 = $RefreshSig$();
import { useT } from 'path';
export function useA() {
    var _a;
    $c0();
    const data = useT();
    return (_a = data === null || data === void 0 ? void 0 : data.address) !== null && _a !== void 0 ? _a : '';
}
$c0(useA, "BHMWiLFX1S0sU8Y04q/J5c/Z4J8=", false, () => [useT]);

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 1`] = `
var $c1;
var $c0;
$c0 = $RefreshSig$();
export function StateTest() {
    $c0();
    const a = useState(0, extra);
    const [b] = useState(complex + expression.f());
    const [c, d] = React.useState();
    const [[e], f] = useState([0]);
    const { 0: y, 1: z, length } = useState(() => {
        a();
        multiple();
        line();
        expression();
    });
}
$c1 = StateTest;
$RefreshReg$($c1, "StateTest");
$c0(StateTest, \`useState{a(0)}
useState{[b](complex + expression.f())}
useState{[c, d]}
useState{[[e], f]([0])}
useState{{0: y, 1: z, length}(() => {
    a()
    multiple()
    line()
    expression()
  })}\`);

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 2`] = `
var $c1;
var $c0;
$c0 = $RefreshSig$();
export function RefTest() {
    $c0();
    const ref = useRef();
    const ref2 = useRef(complex.expr(1), extra);
    const { current } = React.useRef();
}
$c1 = RefTest;
$RefreshReg$($c1, "RefTest");
$c0(RefTest, \`useRef{ref}
useRef{ref2}
useRef{{current}}\`);

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 3`] = `
var $c1;
var $c0;
$c0 = $RefreshSig$();
export function EffectTest() {
    $c0();
    const rtn = useEffect();
    useEffect(expr, [deps]);
    useEffect(() => {
        do_some();
    });
    useEffect(() => (sideEffect(), () => undo()));
}
$c1 = EffectTest;
$RefreshReg$($c1, "EffectTest");
$c0(EffectTest, \`useEffect{rtn}
useEffect{}
useEffect{}
useEffect{}\`);

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 4`] = `
var $c1;
var $c0;
$c0 = $RefreshSig$();
export function ContextTest() {
    $c0();
    const ctx = useContext(expr);
    const { val } = useContext(expr2, extra);
    useContext(expr3);
}
$c1 = ContextTest;
$RefreshReg$($c1, "ContextTest");
$c0(ContextTest, \`useContext{ctx}
useContext{{val}}
useContext{}\`);

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 5`] = `
var $c1;
var $c0;
$c0 = $RefreshSig$();
export function ReducerTest() {
    $c0();
    const [state, dispatch] = useReducer(reducer, initArg, init, extra);
    useReducer();
}
$c1 = ReducerTest;
$RefreshReg$($c1, "ReducerTest");
$c0(ReducerTest, \`useReducer{[state, dispatch](initArg)}
useReducer{}\`);

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 6`] = `
var $c1;
var $c0;
$c0 = $RefreshSig$();
export function CallbackTest() {
    $c0();
    const x = useCallback(() => { });
    const [p] = [useCallback(a, [a, b])];
}
$c1 = CallbackTest;
$RefreshReg$($c1, "CallbackTest");
$c0(CallbackTest, \`useCallback{x}
useCallback{}\`);

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 7`] = `
var $c1;
var $c0;
$c0 = $RefreshSig$();
export function MemoTest() {
    $c0();
    const x = useMemo(() => { });
    const [p] = [useMemo(a, [a, b])];
}
$c1 = MemoTest;
$RefreshReg$($c1, "MemoTest");
$c0(MemoTest, \`useMemo{x}
useMemo{}\`);

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 8`] = `
var $c2, $c3, $c4;
var $c0, $c1;
$c0 = $RefreshSig$();
$c1 = $RefreshSig$();
function ImperativeHandle(props, ref) {
    $c0();
    const v = useImperativeHandle(ref, () => ({ a }));
}
$c2 = ImperativeHandle;
$RefreshReg$($c2, "ImperativeHandle");
$c0(ImperativeHandle, "useImperativeHandle{v}");
ImperativeHandle = forwardRef(ImperativeHandle);
const HOC = forwardRef($c3 = $c1(function (props, ref) {
    $c1();
    const v = useImperativeHandle(ref, () => ({ a }));
}, "useImperativeHandle{v}"));
$RefreshReg$($c3, "HOC$forwardRef");
$c4 = HOC;
$RefreshReg$($c4, "HOC");

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 9`] = `
var $c1;
var $c0;
$c0 = $RefreshSig$();
function LayoutEffect() { $c0(); const v = useLayoutEffect(ref); }
$c1 = LayoutEffect;
$RefreshReg$($c1, "LayoutEffect");
$c0(LayoutEffect, "useLayoutEffect{v}");

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 10`] = `
var $c1;
var $c0;
$c0 = $RefreshSig$();
function DebugValue() { $c0(); const v = useDebugValue(ref, f); }
$c1 = DebugValue;
$RefreshReg$($c1, "DebugValue");
$c0(DebugValue, "useDebugValue{v}");

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for custom hooks 1`] = `
var $c1;
var $c0;
$c0 = $RefreshSig$();
function A() {
    $c0();
    const [x] = useCustom(1, 2, 3);
    useCustom();
}
$c1 = A;
$RefreshReg$($c1, "A");
$c0(A, \`useCustom{[x]}
useCustom{}\`, true);

`;

exports[`ReactFreshTypeScriptTransformer should recognize reset comment 1`] = `
var $c2, $c3;
var $c0, $c1;
$c0 = $RefreshSig$();
$c1 = $RefreshSig$();
// @refresh reset
function App() { $c0(); useState(0); }
$c2 = App;
$RefreshReg$($c2, "App");
$c0(App, "useState{(0)}", true);
// Should not be reset?
function Not() { $c1(); useState(0); }
$c3 = Not;
$RefreshReg$($c3, "Not");
$c1(Not, "useState{(0)}", true);

`;

exports[`ReactFreshTypeScriptTransformer should track custom hooks 1`] = `
var $c1;
var $c0;
$c0 = $RefreshSig$();
import { useImport } from 'path';
import useImportDefault from 'path';
import { a as useAliasImport } from 'path';
import ReactUse from 'react-use';
import * as all from 'react-use';
function App() { $c0(); useImport(useImportDefault(useAliasImport(ReactUse.useTimer(all.useA())))); }
$c1 = App;
$RefreshReg$($c1, "App");
$c0(App, \`useImport{}
useImportDefault{}
useAliasImport{}
ReactUse.useTimer{}
all.useA{}\`, false, () => [useImport, useImportDefault, useAliasImport, ReactUse.useTimer, all.useA]);

`;

exports[`ReactFreshTypeScriptTransformer should track custom hooks 2`] = `
var $c3;
var $c0, $c1, $c2;
$c0 = $RefreshSig$();
$c1 = $RefreshSig$();
$c2 = $RefreshSig$();
function useLocal() { $c0(); return useState(0); }
$c0(useLocal, "useState{(0)}");
const useLocal2 = $c1(() => ($c1(), useLocal()), "useLocal{}", false, () => [useLocal]);
function App() { $c2(); useLocal(useLocal2()); }
$c3 = App;
$RefreshReg$($c3, "App");
$c2(App, \`useLocal{}
useLocal2{}\`, false, () => [useLocal, useLocal2]);

`;

exports[`ReactFreshTypeScriptTransformer should track custom hooks 3`] = `
var $c3;
var $c2;
$c2 = $RefreshSig$();
function App() {
    $c2();
    var $c0, $c1;
    $c0 = $RefreshSig$();
    $c1 = $RefreshSig$();
    function useLocal() { $c0(); return useState(0); }
    $c0(useLocal, "useState{(0)}");
    const useLocal2 = $c1(() => ($c1(), useLocal()), "useLocal{}", false, () => [useLocal]);
    useLocal(useLocal2());
}
$c3 = App;
$RefreshReg$($c3, "App");
$c2(App, \`useLocal{}
useLocal2{}\`, true);

`;

exports[`ReactFreshTypeScriptTransformer should track custom hooks 4`] = `
var $c1;
var $c0;
$c0 = $RefreshSig$();
function App() {
    $c0();
    useDeclarationNotFound();
}
$c1 = App;
$RefreshReg$($c1, "App");
$c0(App, "useDeclarationNotFound{}", true);

`;

exports[`ReactFreshTypeScriptTransformer uses custom identifiers for $RefreshReg$ and $RefreshSig$ 1`] = `
var $c1;
var $c0;
$c0 = import.meta.refreshSig();
export default function Bar() {
    $c0();
    useContext(X);
    return <Foo />;
}
$c1 = Bar;
import.meta.refreshReg($c1, "Bar");
$c0(Bar, "useContext{}");
;

`;

exports[`ReactFreshTypeScriptTransformer uses original function declaration if it get reassigned 1`] = `
var $c0;
function Hello() {
    return <h1>Hi</h1>;
}
$c0 = Hello;
$RefreshReg$($c0, "Hello");
Hello = connect(Hello);

`;
