// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ReactFreshTypeScriptTransformer can handle implicit arrow returns 1`] = `
var _a, _b, _c, _d, _e;
var _f, _g, _h, _j, _k, _l;
_f = $RefreshSig$();
_g = $RefreshSig$();
_h = $RefreshSig$();
_j = $RefreshSig$();
_k = $RefreshSig$();
_l = $RefreshSig$();
export default _f(() => (_f(), useContext(X)), "useContext{}");
export const Foo = _g(() => (_g(), useContext(X)), "useContext{}");
_a = Foo;
$RefreshReg$(_a, "Foo");
module.exports = () => (_h(), useContext(X));
const Bar = _j(() => (_j(), useContext(X)), "useContext{}");
_b = Bar;
$RefreshReg$(_b, "Bar");
const Baz = memo(_c = _k(() => (_k(), useContext(X)), "useContext{}"));
$RefreshReg$(_c, "Baz$memo");
_d = Baz;
$RefreshReg$(_d, "Baz");
const Qux = _l(() => (_l(), (0, useContext(X))), "useContext{}");
_e = Qux;
$RefreshReg$(_e, "Qux");

`;

exports[`ReactFreshTypeScriptTransformer does not consider require-like methods to be HOCs 1`] = `
var _a;
const A = require('A');
const B = foo ? require('X') : require('Y');
const C = requireCond(gk, 'C');
const D = import('D');
export default function App() {
    return (<div>
      <A />
      <B />
      <C />
      <D />
    </div>);
}
_a = App;
$RefreshReg$(_a, "App");

`;

exports[`ReactFreshTypeScriptTransformer generates signatures for function declarations calling hooks 1`] = `
var _a;
var _b;
_b = $RefreshSig$();
export default function App() {
    _b();
    const [foo, setFoo] = useState(0);
    React.useEffect(() => { });
    return <h1>{foo}</h1>;
}
_a = App;
$RefreshReg$(_a, "App");
_b(App, \`useState{[foo, setFoo](0)}
useEffect{}\`);

`;

exports[`ReactFreshTypeScriptTransformer generates signatures for function expressions calling hooks 1`] = `
var _a, _b, _c, _d, _e, _f;
var _g, _h;
_g = $RefreshSig$();
_h = $RefreshSig$();
export const A = React.memo(_a = React.forwardRef(_b = _g((props, ref) => {
    _g();
    const [foo, setFoo] = useState(0);
    React.useEffect(() => { });
    return <h1 ref={ref}>{foo}</h1>;
}, \`useState{[foo, setFoo](0)}
useEffect{}\`)));
$RefreshReg$(_b, "A$React.memo$React.forwardRef");
$RefreshReg$(_a, "A$React.memo");
_c = A;
$RefreshReg$(_c, "A");
export const B = React.memo(_d = React.forwardRef(_e = _h(function (props, ref) {
    _h();
    const [foo, setFoo] = useState(0);
    React.useEffect(() => { });
    return <h1 ref={ref}>{foo}</h1>;
}, \`useState{[foo, setFoo](0)}
useEffect{}\`)));
$RefreshReg$(_e, "B$React.memo$React.forwardRef");
$RefreshReg$(_d, "B$React.memo");
_f = B;
$RefreshReg$(_f, "B");
function hoc() {
    var _j;
    _j = $RefreshSig$();
    return _j(function Inner() {
        _j();
        const [foo, setFoo] = useState(0);
        React.useEffect(() => { });
        return <h1 ref={ref}>{foo}</h1>;
    }, \`useState{[foo, setFoo](0)}
useEffect{}\`);
}
export let C = hoc();

`;

exports[`ReactFreshTypeScriptTransformer generates valid signature for exotic ways to call Hooks 1`] = `
var _a;
var _b;
_b = $RefreshSig$();
import FancyHook from 'fancy';
export default function App() {
    _b();
    var _c;
    _c = $RefreshSig$();
    function useFancyState() {
        _c();
        const [foo, setFoo] = React.useState(0);
        useFancyEffect();
        return foo;
    }
    _c(useFancyState, \`useState{[foo, setFoo](0)}
useFancyEffect{}\`, true);
    const bar = useFancyState();
    const baz = FancyHook.useThing();
    React.useState();
    useThePlatform();
    return <h1>{bar}{baz}</h1>;
}
_a = App;
$RefreshReg$(_a, "App");
_b(App, \`useFancyState{bar}
FancyHook.useThing{baz}
useState{}
useThePlatform{}\`, true);

`;

exports[`ReactFreshTypeScriptTransformer ignores HOC definitions 1`] = `
let connect = () => {
    function Comp() {
        const handleClick = () => { };
        return <h1 onClick={handleClick}>Hi</h1>;
    }
    return Comp;
};
function withRouter() {
    return function Child() {
        const handleClick = () => { };
        return <h1 onClick={handleClick}>Hi</h1>;
    };
}
;

`;

exports[`ReactFreshTypeScriptTransformer ignores complex definitions 1`] = `
var _a;
let A = foo ? () => {
    return <h1>Hi</h1>;
} : null;
const B = (function Foo() {
    return <h1>Hi</h1>;
})();
let C = () => () => {
    return <h1>Hi</h1>;
};
_a = C;
$RefreshReg$(_a, "C");
let D = bar && (() => {
    return <h1>Hi</h1>;
});

`;

exports[`ReactFreshTypeScriptTransformer ignores higher-order functions that are not HOCs 1`] = `
var _a;
const throttledAlert = throttle(_a = function () {
    alert('Hi');
});
$RefreshReg$(_a, "throttledAlert$throttle");
const TooComplex = (function () { return hello; })(() => { });
if (cond) {
    const Foo = thing(() => { });
}

`;

exports[`ReactFreshTypeScriptTransformer ignores unnamed function declarations 1`] = `
export default function () { }

`;

exports[`ReactFreshTypeScriptTransformer includes custom hooks into the signatures 1`] = `
var _a;
var _b, _c, _d;
_b = $RefreshSig$();
_c = $RefreshSig$();
_d = $RefreshSig$();
function useFancyState() {
    _b();
    const [foo, setFoo] = React.useState(0);
    useFancyEffect();
    return foo;
}
_b(useFancyState, \`useState{[foo, setFoo](0)}
useFancyEffect{}\`, false, () => [useFancyEffect]);
const useFancyEffect = _c(() => {
    _c();
    React.useEffect(() => { });
}, "useEffect{}");
export default function App() {
    _d();
    const bar = useFancyState();
    return <h1>{bar}</h1>;
}
_a = App;
$RefreshReg$(_a, "App");
_d(App, "useFancyState{bar}", false, () => [useFancyState]);

`;

exports[`ReactFreshTypeScriptTransformer includes custom hooks into the signatures when commonjs target is used 1`] = `
var _a;
var _b;
_b = $RefreshSig$();
import { useFancyState } from './hooks';
export default function App() {
    _b();
    const bar = useFancyState();
    return <h1>{bar}</h1>;
}
_a = App;
$RefreshReg$(_a, "App");
_b(App, "useFancyState{bar}", false, () => [useFancyState]);

`;

exports[`ReactFreshTypeScriptTransformer only registers pascal case functions 1`] = `
function hello() {
    return 2 * 2;
}

`;

exports[`ReactFreshTypeScriptTransformer registers capitalized identifiers in HOC calls 1`] = `
var _a, _b, _c, _d;
function Foo() {
    return <h1>Hi</h1>;
}
_a = Foo;
$RefreshReg$(_a, "Foo");
export default _b = hoc(Foo);
$RefreshReg$(_b, "%default%");
export const A = hoc(Foo);
_c = A;
$RefreshReg$(_c, "A");
const B = hoc(Foo);
_d = B;
$RefreshReg$(_d, "B");

`;

exports[`ReactFreshTypeScriptTransformer registers identifiers used in JSX at definition site 1`] = `
var _a, _b, _c, _d, _e, _f, _g;
import A from './A';
import Store from './Store';
Store.subscribe();
const Header = styled.div \`color: red\`;
_a = Header;
$RefreshReg$(_a, "Header");
const StyledFactory1 = styled('div') \`color: hotpink\`;
_b = StyledFactory1;
$RefreshReg$(_b, "StyledFactory1");
const StyledFactory2 = styled('div')({ color: 'hotpink' });
_c = StyledFactory2;
$RefreshReg$(_c, "StyledFactory2");
const StyledFactory3 = styled(A)({ color: 'hotpink' });
_d = StyledFactory3;
$RefreshReg$(_d, "StyledFactory3");
const FunnyFactory = funny.factory \`\`;
let Alias1 = A;
let Alias2 = A.Foo;
const Dict = {};
function Foo() {
    return (<div><A /><B /><StyledFactory1 /><StyledFactory2 /><StyledFactory3 /><Alias1 /><Alias2 /><Header /><Dict.X /></div>);
}
_e = Foo;
$RefreshReg$(_e, "Foo");
const B = hoc(A);
_f = B;
$RefreshReg$(_f, "B");
// This is currently registered as a false positive:
const NotAComponent = wow(A);
_g = NotAComponent;
$RefreshReg$(_g, "NotAComponent");

`;

exports[`ReactFreshTypeScriptTransformer registers identifiers used in React.createElement at definition site 1`] = `
var _a, _b, _c, _d, _e, _f, _g;
import A from './A';
import Store from './Store';
Store.subscribe();
const Header = styled.div \`color: red\`;
_a = Header;
$RefreshReg$(_a, "Header");
const StyledFactory1 = styled('div') \`color: hotpink\`;
_b = StyledFactory1;
$RefreshReg$(_b, "StyledFactory1");
const StyledFactory2 = styled('div')({ color: 'hotpink' });
_c = StyledFactory2;
$RefreshReg$(_c, "StyledFactory2");
const StyledFactory3 = styled(A)({ color: 'hotpink' });
_d = StyledFactory3;
$RefreshReg$(_d, "StyledFactory3");
const FunnyFactory = funny.factory \`\`;
let Alias1 = A;
let Alias2 = A.Foo;
const Dict = {};
function Foo() {
    return [
        React.createElement(A),
        React.createElement(B),
        React.createElement(StyledFactory1),
        React.createElement(StyledFactory2),
        React.createElement(StyledFactory3),
        React.createElement(Alias1),
        React.createElement(Alias2),
        jsx(Header),
        React.createElement(Dict.X),
    ];
}
_e = Foo;
$RefreshReg$(_e, "Foo");
React.createContext(Store);
const B = hoc(A);
_f = B;
$RefreshReg$(_f, "B");
// This is currently registered as a false positive:
const NotAComponent = wow(A);
_g = NotAComponent;
$RefreshReg$(_g, "NotAComponent");

`;

exports[`ReactFreshTypeScriptTransformer registers likely HOCs with inline functions 1`] = `
var _a, _b, _c, _d, _e, _f, _g, _h;
const A = forwardRef(_a = function () {
    return <h1>Foo</h1>;
});
$RefreshReg$(_a, "A$forwardRef");
_b = A;
$RefreshReg$(_b, "A");
const B = memo(_c = React.forwardRef(_d = () => {
    return <h1>Foo</h1>;
}));
$RefreshReg$(_d, "B$memo$React.forwardRef");
$RefreshReg$(_c, "B$memo");
_e = B;
$RefreshReg$(_e, "B");
export default _h = React.memo(_f = forwardRef(_g = (props, ref) => {
    return <h1>Foo</h1>;
}));
$RefreshReg$(_h, "%default%");
$RefreshReg$(_g, "%default%$React.memo$forwardRef");
$RefreshReg$(_f, "%default%$React.memo");

`;

exports[`ReactFreshTypeScriptTransformer registers likely HOCs with inline functions 2`] = `
var _a, _b, _c;
export default _c = React.memo(_a = forwardRef(_b = function (props, ref) {
    return <h1>Foo</h1>;
}));
$RefreshReg$(_c, "%default%");
$RefreshReg$(_b, "%default%$React.memo$forwardRef");
$RefreshReg$(_a, "%default%$React.memo");

`;

exports[`ReactFreshTypeScriptTransformer registers likely HOCs with inline functions 3`] = `
var _a, _b, _c;
export default _c = React.memo(_a = forwardRef(_b = function Named(props, ref) {
    return <h1>Foo</h1>;
}));
$RefreshReg$(_c, "%default%");
$RefreshReg$(_b, "%default%$React.memo$forwardRef");
$RefreshReg$(_a, "%default%$React.memo");

`;

exports[`ReactFreshTypeScriptTransformer registers top-level exported function declarations 1`] = `
var _a, _b, _c;
export function Hello() {
    function handleClick() { }
    return <h1 onClick={handleClick}>Hi</h1>;
}
_a = Hello;
$RefreshReg$(_a, "Hello");
export default function Bar() {
    return <Hello />;
}
_b = Bar;
$RefreshReg$(_b, "Bar");
function Baz() {
    return <h1>OK</h1>;
}
_c = Baz;
$RefreshReg$(_c, "Baz");
const NotAComp = 'hi';
export { Baz, NotAComp };
export function sum() { }
export const Bad = 42;

`;

exports[`ReactFreshTypeScriptTransformer registers top-level exported named arrow functions 1`] = `
var _a, _b;
export const Hello = () => {
    function handleClick() { }
    return <h1 onClick={handleClick}>Hi</h1>;
};
_a = Hello;
$RefreshReg$(_a, "Hello");
export let Bar = (props) => <Hello />;
_b = Bar;
$RefreshReg$(_b, "Bar");
export default () => {
    // This one should be ignored.
    // You should name your components.
    return <Hello />;
};

`;

exports[`ReactFreshTypeScriptTransformer registers top-level function declarations 1`] = `
var _a, _b;
function Hello() {
    function handleClick() { }
    return <h1 onClick={handleClick}>Hi</h1>;
}
_a = Hello;
$RefreshReg$(_a, "Hello");
function Bar() {
    return <Hello />;
}
_b = Bar;
$RefreshReg$(_b, "Bar");

`;

exports[`ReactFreshTypeScriptTransformer registers top-level variable declarations with arrow functions 1`] = `
var _a, _b, _c;
let Hello = () => {
    const handleClick = () => { };
    return <h1 onClick={handleClick}>Hi</h1>;
};
_a = Hello;
$RefreshReg$(_a, "Hello");
const Bar = () => {
    return <Hello />;
};
_b = Bar;
$RefreshReg$(_b, "Bar");
var Baz = () => <div />;
_c = Baz;
$RefreshReg$(_c, "Baz");
var sum = () => { };

`;

exports[`ReactFreshTypeScriptTransformer registers top-level variable declarations with function expressions 1`] = `
var _a, _b;
let Hello = function () {
    function handleClick() { }
    return <h1 onClick={handleClick}>Hi</h1>;
};
_a = Hello;
$RefreshReg$(_a, "Hello");
const Bar = function Baz() {
    return <Hello />;
};
_b = Bar;
$RefreshReg$(_b, "Bar");
function sum() { }
let Baz = 10;
var Qux;

`;

exports[`ReactFreshTypeScriptTransformer should correctly compile when downgrade 1`] = `
var _a;
_a = $RefreshSig$();
import { useT } from 'path';
export function useA() {
    var _b;
    _a();
    const data = useT();
    return (_b = data === null || data === void 0 ? void 0 : data.address) !== null && _b !== void 0 ? _b : '';
}
_a(useA, "BHMWiLFX1S0sU8Y04q/J5c/Z4J8=", false, () => [useT]);

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 1`] = `
var _a;
var _b;
_b = $RefreshSig$();
export function StateTest() {
    _b();
    const a = useState(0, extra);
    const [b] = useState(complex + expression.f());
    const [c, d] = React.useState();
    const [[e], f] = useState([0]);
    const { 0: y, 1: z, length } = useState(() => {
        a();
        multiple();
        line();
        expression();
    });
}
_a = StateTest;
$RefreshReg$(_a, "StateTest");
_b(StateTest, \`useState{a(0)}
useState{[b](complex + expression.f())}
useState{[c, d]}
useState{[[e], f]([0])}
useState{{0: y, 1: z, length}(() => {
    a()
    multiple()
    line()
    expression()
  })}\`);

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 2`] = `
var _a;
var _b;
_b = $RefreshSig$();
export function RefTest() {
    _b();
    const ref = useRef();
    const ref2 = useRef(complex.expr(1), extra);
    const { current } = React.useRef();
}
_a = RefTest;
$RefreshReg$(_a, "RefTest");
_b(RefTest, \`useRef{ref}
useRef{ref2}
useRef{{current}}\`);

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 3`] = `
var _a;
var _b;
_b = $RefreshSig$();
export function EffectTest() {
    _b();
    const rtn = useEffect();
    useEffect(expr, [deps]);
    useEffect(() => {
        do_some();
    });
    useEffect(() => (sideEffect(), () => undo()));
}
_a = EffectTest;
$RefreshReg$(_a, "EffectTest");
_b(EffectTest, \`useEffect{rtn}
useEffect{}
useEffect{}
useEffect{}\`);

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 4`] = `
var _a;
var _b;
_b = $RefreshSig$();
export function ContextTest() {
    _b();
    const ctx = useContext(expr);
    const { val } = useContext(expr2, extra);
    useContext(expr3);
}
_a = ContextTest;
$RefreshReg$(_a, "ContextTest");
_b(ContextTest, \`useContext{ctx}
useContext{{val}}
useContext{}\`);

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 5`] = `
var _a;
var _b;
_b = $RefreshSig$();
export function ReducerTest() {
    _b();
    const [state, dispatch] = useReducer(reducer, initArg, init, extra);
    useReducer();
}
_a = ReducerTest;
$RefreshReg$(_a, "ReducerTest");
_b(ReducerTest, \`useReducer{[state, dispatch](initArg)}
useReducer{}\`);

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 6`] = `
var _a;
var _b;
_b = $RefreshSig$();
export function CallbackTest() {
    _b();
    const x = useCallback(() => { });
    const [p] = [useCallback(a, [a, b])];
}
_a = CallbackTest;
$RefreshReg$(_a, "CallbackTest");
_b(CallbackTest, \`useCallback{x}
useCallback{}\`);

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 7`] = `
var _a;
var _b;
_b = $RefreshSig$();
export function MemoTest() {
    _b();
    const x = useMemo(() => { });
    const [p] = [useMemo(a, [a, b])];
}
_a = MemoTest;
$RefreshReg$(_a, "MemoTest");
_b(MemoTest, \`useMemo{x}
useMemo{}\`);

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 8`] = `
var _a, _b, _c;
var _d, _e;
_d = $RefreshSig$();
_e = $RefreshSig$();
function ImperativeHandle(props, ref) {
    _d();
    const v = useImperativeHandle(ref, () => ({ a }));
}
_a = ImperativeHandle;
$RefreshReg$(_a, "ImperativeHandle");
_d(ImperativeHandle, "useImperativeHandle{v}");
ImperativeHandle = forwardRef(ImperativeHandle);
const HOC = forwardRef(_b = _e(function (props, ref) {
    _e();
    const v = useImperativeHandle(ref, () => ({ a }));
}, "useImperativeHandle{v}"));
$RefreshReg$(_b, "HOC$forwardRef");
_c = HOC;
$RefreshReg$(_c, "HOC");

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 9`] = `
var _a;
var _b;
_b = $RefreshSig$();
function LayoutEffect() { _b(); const v = useLayoutEffect(ref); }
_a = LayoutEffect;
$RefreshReg$(_a, "LayoutEffect");
_b(LayoutEffect, "useLayoutEffect{v}");

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for built-in hooks 10`] = `
var _a;
var _b;
_b = $RefreshSig$();
function DebugValue() { _b(); const v = useDebugValue(ref, f); }
_a = DebugValue;
$RefreshReg$(_a, "DebugValue");
_b(DebugValue, "useDebugValue{v}");

`;

exports[`ReactFreshTypeScriptTransformer should generate signature for custom hooks 1`] = `
var _a;
var _b;
_b = $RefreshSig$();
function A() {
    _b();
    const [x] = useCustom(1, 2, 3);
    useCustom();
}
_a = A;
$RefreshReg$(_a, "A");
_b(A, \`useCustom{[x]}
useCustom{}\`, true);

`;

exports[`ReactFreshTypeScriptTransformer should recognize reset comment 1`] = `
var _a, _b;
var _c, _d;
_c = $RefreshSig$();
_d = $RefreshSig$();
// @refresh reset
function App() { _c(); useState(0); }
_a = App;
$RefreshReg$(_a, "App");
_c(App, "useState{(0)}", true);
// Should not be reset?
function Not() { _d(); useState(0); }
_b = Not;
$RefreshReg$(_b, "Not");
_d(Not, "useState{(0)}", true);

`;

exports[`ReactFreshTypeScriptTransformer should track custom hooks 1`] = `
var _a;
var _b;
_b = $RefreshSig$();
import { useImport } from 'path';
import useImportDefault from 'path';
import { a as useAliasImport } from 'path';
import ReactUse from 'react-use';
import * as all from 'react-use';
function App() { _b(); useImport(useImportDefault(useAliasImport(ReactUse.useTimer(all.useA())))); }
_a = App;
$RefreshReg$(_a, "App");
_b(App, \`useImport{}
useImportDefault{}
useAliasImport{}
ReactUse.useTimer{}
all.useA{}\`, false, () => [useImport, useImportDefault, useAliasImport, ReactUse.useTimer, all.useA]);

`;

exports[`ReactFreshTypeScriptTransformer should track custom hooks 2`] = `
var _a;
var _b, _c, _d;
_b = $RefreshSig$();
_c = $RefreshSig$();
_d = $RefreshSig$();
function useLocal() { _b(); return useState(0); }
_b(useLocal, "useState{(0)}");
const useLocal2 = _c(() => (_c(), useLocal()), "useLocal{}", false, () => [useLocal]);
function App() { _d(); useLocal(useLocal2()); }
_a = App;
$RefreshReg$(_a, "App");
_d(App, \`useLocal{}
useLocal2{}\`, false, () => [useLocal, useLocal2]);

`;

exports[`ReactFreshTypeScriptTransformer should track custom hooks 3`] = `
var _a;
var _b;
_b = $RefreshSig$();
function App() {
    _b();
    var _c, _d;
    _c = $RefreshSig$();
    _d = $RefreshSig$();
    function useLocal() { _c(); return useState(0); }
    _c(useLocal, "useState{(0)}");
    const useLocal2 = _d(() => (_d(), useLocal()), "useLocal{}", false, () => [useLocal]);
    useLocal(useLocal2());
}
_a = App;
$RefreshReg$(_a, "App");
_b(App, \`useLocal{}
useLocal2{}\`, true);

`;

exports[`ReactFreshTypeScriptTransformer should track custom hooks 4`] = `
var _a;
var _b;
_b = $RefreshSig$();
function App() {
    _b();
    useDeclarationNotFound();
}
_a = App;
$RefreshReg$(_a, "App");
_b(App, "useDeclarationNotFound{}", true);

`;

exports[`ReactFreshTypeScriptTransformer uses custom identifiers for $RefreshReg$ and $RefreshSig$ 1`] = `
var _a;
var _b;
_b = import.meta.refreshSig();
export default function Bar() {
    _b();
    useContext(X);
    return <Foo />;
}
_a = Bar;
import.meta.refreshReg(_a, "Bar");
_b(Bar, "useContext{}");
;

`;

exports[`ReactFreshTypeScriptTransformer uses original function declaration if it get reassigned 1`] = `
var _a;
function Hello() {
    return <h1>Hi</h1>;
}
_a = Hello;
$RefreshReg$(_a, "Hello");
Hello = connect(Hello);

`;
