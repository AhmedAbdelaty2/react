---
id: jsx-in-depth-ru-RU
title: Подробно про JSX
permalink: jsx-in-depth-ru-RU.html
prev: displaying-data-ru-RU.html
next: jsx-spread.html
---

[JSX](https://facebook.github.io/jsx/) - это расширение синтаксиса JavaScript, имеющее схожий с XML вид. С React вы можете пользоваться простым преобразованием синтаксиса JSX в JavaScript.

## Почему JSX?

При работе с React использование JSX не обязательно. Однако мы рекомендуем JSX, так как это сжатый и знакомый синтаксис для описания древообразных структур с атрибутами.

Он более привычен неспециалистам в разработке, в том числе дизайнерам.

Преимуществом XML является сбалансированность открывающих и закрывающих тегов, благодаря чему большие деревья более читаемы, нежели вызовы функций или литералы объектов.

Он не изменяет семантику языка JavaScript.

## HTML теги и React-компоненты

React может отрисовывать либо HTML-теги (строки), либо React-компоненты (классы).

Чтобы отобразить HTML-тег, просто используйте строчные буквы в именах тегов:

```javascript
var myDivElement = <div className="foo" />;
ReactDOM.render(myDivElement, document.getElementById('example'));
```

Чтобы отобразить React-компонент, объявите локальную переменную с именем, начинающимся на прописную букву:

```javascript
var MyComponent = React.createClass({/*...*/});
var myElement = <MyComponent someProperty={true} />;
ReactDOM.render(myElement, document.getElementById('example'));
```

JSX в React использует это соглашение, чтобы различать классы компонентов и HTML-теги в зависимости от регистра.

> Замечание:
>
> Так как JSX - это JavaScript, идентификаторы `class` и `for` не следует
> использовать в качестве имен атрибутов. Вместо этого, компоненты React DOM ожидают
> имена свойств `className` и `htmlFor`, соответственно.

## Преобразование

React JSX преобразуется из XML-подобного синтаксиса в JavaScript. XML-элементы, атрибуты и дочерние элементы преобразуются в аргументы, передаваемые в `React.createElement`.

```javascript
var Nav;
// Вход (JSX):
var app = <Nav color="blue" />;
// Выход (JS):
var app = React.createElement(Nav, {color:"blue"});
```

Обратите внимание: для использования `<Nav />` необходимо, чтобы переменная `Nav` существовала в области видимости.

JSX также позволяет указывать дочерние элементы с помощью синтаксиса XML:

```javascript
var Nav, Profile;
// Вход (JSX):
var app = <Nav color="blue"><Profile>click</Profile></Nav>;
// Выход (JS):
var app = React.createElement(
  Nav,
  {color:"blue"},
  React.createElement(Profile, null, "click")
);
```

JSX возьмет значение [displayName](/react/docs/component-specs.html#displayname) для класса из присваивания к переменной в случае, когда displayName не определен:

```javascript
// Вход (JSX):
var Nav = React.createClass({ });
// Выход (JS):
var Nav = React.createClass({displayName: "Nav", });
```

Воспользуйтесь [Babel REPL](https://babeljs.io/repl/), чтобы опробовать JSX и увидеть, как он превращается в обычный JavaScript, а также [конвертером HTML в JSX](http://magic.reactjs.net/htmltojsx.htm) для преобразования вашего существующего HTML в JSX.

Если вы решили воспользоваться JSX, страница [Getting Started](/react/docs/getting-started.html) содержит информацию о том, как настроить компиляцию.

> Замечание:
>
> Значением JSX-выражения всегда является ReactElement. Детали
> реализации могут варьироваться. В режиме оптимизации ReactElement
> может подставляться в виде литерала объекта, чтобы обойти проверки
> в `React.createElement`.

## Компоненты в пространствах имен

При построении компонента с множеством дочерних элементов - к примеру, формы - вы можете прийти к ситуации, когда приходится объявлять множество переменных:

```javascript
// Некрасивый блок объявления переменных
var Form = MyFormComponent;
var FormRow = Form.Row;
var FormLabel = Form.Label;
var FormInput = Form.Input;

var App = (
  <Form>
    <FormRow>
      <FormLabel />
      <FormInput />
    </FormRow>
  </Form>
);
```

С помощью *пространства имен*, вы можете использовать один компонент, содержащий другие компоненты в качестве свойств:

```javascript
var Form = MyFormComponent;

var App = (
  <Form>
    <Form.Row>
      <Form.Label />
      <Form.Input />
    </Form.Row>
  </Form>
);
```

Для этого нужно создать ваши *"под-компоненты"* как свойства главного компонента:

```javascript
var MyFormComponent = React.createClass({ ... });

MyFormComponent.Row = React.createClass({ ... });
MyFormComponent.Label = React.createClass({ ... });
MyFormComponent.Input = React.createClass({ ... });
```

JSX корректно обработает этот код при его компиляции.

```javascript
var App = (
  React.createElement(Form, null,
    React.createElement(Form.Row, null,
      React.createElement(Form.Label, null),
      React.createElement(Form.Input, null)
    )
  )
);
```

> Замечание:
>
> Эта возможность доступна в версии [0.11](/react/blog/2014/07/17/react-v0.11.html#jsx) и выше.

## JavaScript-выражения

### Выражения в атрибутах

Чтобы использовать JavaScript-выражение в качестве значения атрибута, оберните это выражение в фигурные скобки (`{}`) вместо кавычек (`""`).

```javascript
// Вход (JSX):
var person = <Person name={window.isLoggedIn ? window.name : ''} />;
// Выход (JS):
var person = React.createElement(
  Person,
  {name: window.isLoggedIn ? window.name : ''}
);
```

### Логические атрибуты

Если значение атрибута опущено, JSX полагает его равным `true`. Чтобы передать `false`, следует использовать выражение для атрибута. Зачастую с этим можно столкнуться при использовании HTML-элементов в формах с атрибутами вроде `disabled`, `required`, `checked` и `readOnly`.

```javascript
// Следующие два элемента эквивалентны в JSX для задания недоступной кнопки
<input type="button" disabled />;
<input type="button" disabled={true} />;

// А эти два эквивалентны в JSX для задания кнопки, не являющейся недоступной
<input type="button" />;
<input type="button" disabled={false} />;
```

### Выражения для дочерних элементов

Аналогично, выражения JavaScript могут использоваться для задания дочерних элементов:

```javascript
// Вход (JSX):
var content = <Container>{window.isLoggedIn ? <Nav /> : <Login />}</Container>;
// Выход (JS):
var content = React.createElement(
  Container,
  null,
  window.isLoggedIn ? React.createElement(Nav) : React.createElement(Login)
);
```

### Комментарии

Внутри JSX можно легко добавлять комментарии; они всего лишь являются JS-выражениями. Нужно только заключить комментарии в `{}`, если вы находитесь внутри области дочерних элементов тега.

```javascript
var content = (
  <Nav>
    {/* комментарий в области дочерних элементов */}
    <Person
      /* много-
         строчный
         комментарий */
      name={window.isLoggedIn ? window.name : ''} // комментарий в конце строки
    />
  </Nav>
);
```

> ЗАМЕЧАНИЕ:
>
> Хотя JSX и похож на HTML, они не являются в точности одним и тем же. Ключевые различия описаны в главе [JSX gotchas](/react/docs/jsx-gotchas.html).
